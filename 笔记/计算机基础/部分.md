## 7.3 图的遍历

### 7.3.1 广度优先遍历 BFS

**树的广度优先遍历：层序遍历**

```C++
bool visited[MAX_VERTEX_NUM];	//访问标记数组
void BFSTraverse(Graph G){	//对图进行广度优先遍历
    for(i=0;i<G.vexnum;i++)
        visited[i]=FALSE;	//访问标记数组初始化为FLASE
    InitQueue(Q);	//初始化辅助队列
    for(i=0;i<G.vexnum;++i)	//从0号顶点开始遍历
        if(!visited[i])	//对每个连通分量调用一次BFS
            BFS(G,i);	//vi 未访问过，从vi开始BFS
}
void BFS(Graph G,int v){	//从顶点v出发，广度优先遍历图G
    visit(v);	//访问初始顶点v
    visited(v)=TRUE;	//对v做访问标记
    EnQueue(Q,v);	//顶点v入队列Q
    while(!isEmpty(Q)){
        DeQueue(Q,v);	//顶点v出队
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){//检测v所有邻接点
            if(!visited(w)){	//w为v未访问的邻接顶点
                visit(w);	//访问顶点w
                visited(w)=TRUE;	//对w做已访问标记
            	EnQueue(Q,w);	//顶点w入队
            }//if
        }//for
    }//while
}
```

**遍历序列的可变性：**

-   邻接矩阵：遍历顺序唯一（递增）

-   邻接表：遍历序列不唯一

结论：对于无向图，调用BFS函数的次数=连通分量数

空间复杂度：最坏情况，辅助队列大小为$O(|V|)$=>一个顶点连接其余所有结点，有|v|个结点

**时间复杂度:**

-   邻接矩阵：访问|V|个顶点需要$O(|V|)$的时间，查找每个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点，需要$O(|V|^2)$的时间，时间复杂度=$O(|V|^2+|V|)=O(|V|^2)$
-   邻接表：访问$|V|$个顶点需要$O(|V|)$的时间，查找各个顶点的邻接点共需要$O(|E|)$的时间，时间复杂度=$O(|V|+|E|)$

**广度优先生成树：**在广度优先遍历过程中，可以得到一棵遍历树，称为广度优先生成树。广度优先生成树由广度优先遍历过程决定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一。

对于非连通图的广度优先遍历，可以得到广度优先生成森林。

### 7.3.2 深度优先遍历

-   **递归方式的深度优先遍历：**

```C++
bool visited[MAX_VERTEX_NUM];	//访问标记数组，初始都为false
void DFSTraverse(Grapg G){
    for(v=0;v<G.vexnum;++v)
        visited[v]=FALSE;
    for(v=0;v<G.vexnum;++v)
        if(!visited[v])
            DFS(G,v);
}
void DFS(Graph G,int v){	//从顶点v出发，深度优先遍历图G
    visit(v);	//访问顶点v
    visited(v)=TRUE;	//设已访问标记
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w])	//w为v未访问的邻接顶点
            DFS(G,w);
}
```

-   空间复杂度：来自函数调用栈，最坏情况，递归深度为$O(|V|)$,最好情况$O(1)$

-   时间复杂度：时间复杂度=访问各结点所需时间+探索各条边所需时间

    -   邻接矩阵：访问$|V|$个顶点需要$O(|V|)$的时间，查找各个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点时间复杂度=$O(|V|^2)$

    -   邻接表：访问$|V|$个顶点需要$O(|V|)$的时间，查找各个顶点的邻接点共需要$O(|E|)$的时间，时间复杂度=$O(|V|+|E|)$

-   深度优先遍历序列：邻接矩阵唯一，邻接表不唯一

-   深度优先生成树：深度优先遍历生成的一棵树，称为深度优先生成树。非连通图进行深度优先遍历会生成深度优先生成森林。

-   **图的遍历与图的连通性**
    -   对有向图进行BFS/DFS遍历，调用BFS/DFS函数的次序要具体问题提分析
        -   若起始顶点到其他各顶点都有路径，则只需调用一次DFS/BFS函数
        -   对于强连通图，从任一结点出发都只需调用一次BFS/DFS