# 一、数据结构和算法

# 二、线性表

## 1 线性表的定义和基本操作

### 1.1 线性表的定义

线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。

若用L命名线性表，则其一般表示为 L=（a~1~,a~2~,···,a~i~,a~I+1~,···,a~n~）,式中a~1~是唯一的“第一个”数据元素，又称表头元素；

a~n~是唯一个个"最后一个"数据元素，又称表尾元素。

除第一个元素外，每个数据元素有且仅有一个直接前驱；除最后一个元素外，每个数据元素有且仅有一个直接后继。

### 1.2 线性表的特点

-   表中元素的个数有限。
-   表中元素的都具有逻辑上的顺序性，表中元素有其先后次序。
-   表中元素都是数据元素，每个元素都是单个元素。
-   表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
-   表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。

### 1.3 线性表的抽象数据类型ADT

```C++
ADT List{
数据对象：D={ai|ai=ElemSet,i=1,2,..,n,n≥0}
数据关系：R={<ai-1,ai>|ai-1,ai∈D,i=2,...,n}
基本操作：
IniList(&L)
	操作结果：构造一个空的线性表L。
DestroyList(&L)
    初始条件：线性表L已存在
	操作结果：销毁线性表L
ClearList(&L)
    初始条件：线性表L已存在
	操作结果：将L重置为空表
ListEmpty(L)
    初始条件：线性表L已存在
	操作结果：若L为空表，则返回true，否则返回false
ListLength(L)
    初始条件：线性表L已存在
	操作结果：返回L中数据元素个数
GetElem(L,i,&e)
	初始条件：线性表L已存在，1≤i≤ListLength(L)   
	操作结果：用e返回L中第i个数据元素的值
LocateElem(L,e,compare())
    初始条件：线性表L已存在
	操作结果：返回L中第一个值与e相同的数据元素在L中的位置。若这样的数据元素不存在，则返回值为0.
PriorElem(L,cur_e,&pre_e)
    初始条件：线性表L已存在
	操作结果：若cur-e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义
NextElem(L,cur_e,&next_e)
    初始条件：线性表L已存在
	操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义
ListInsert(&L,i,e)
	初始条件：线性表已存在，1≤i≤ListLength(L)+1
	操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1
ListDelete(&L,i,&e)
	初始条件： 线性表存在且非空，1≤i≤ListLength(L)
	操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
TravarseList(L)
    初始条件：线性表已存在
	操作结果：依次对线性表L进行遍历，在遍历过程中对L的每个结点访问一次
}ADT List
```



## 2 顺序表

### 2.1 顺序表的定义

**顺序表的存储结构：**顺序存储，即逻辑上相邻的数据元素在物理上也相邻

**顺序表的特点：**

1.  ==随机存取==，即可以在O(1)时间内找到第i个元素
2.  存储密度高，每个节点只存储数据元素
3.  拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4.  插入、删除操作不方便，需要移动大量元素

**优点：**可随机存取，存储密度高

**缺点：**需要大片连续的空间，改变容量不方便

#### 2.1.1 顺序表的实现方式

**顺序表有两种实现方式：**

1.  静态分配
    -   使用"静态数组"实现，大小一旦确定就无法改变
2.  动态分配
    -   使用"动态数组"实现
    -   顺序表满时，可以再用new关键字重新申请更大的内存空间来拓展顺序表的最大长度
    -   需要将数据元素复制到新的存储空间，并用delete关键字释放原来的空间

```C++
//静态分配的顺序表（大小一旦确定就无法改变）
#define MAXSIZE 10//线性表的最大长度
typedef struct{
	ElemType data[MAXSIZE];
    int length;
}SqList;
//动态分配的顺序表（使用动态数组实现）
#define INITSIZE 10//顺序表的初始长度
typedef struct{
    ElemType *data;//指示动态分配数组的指针
    int MaxSize;//顺序表的最大容量
    int length;//顺序表当前的长度
}SeqList;
```

#### 2.1.2 初始化顺序表 InitList

**1) 静态分配顺序表**

```C++
//初始化顺序表（固定长度，不设置默认值）
void InitList(SqList &L){
    L.length = 0;
}
//初始化顺序表（固定长度，设置默认值）
void InitList(SqList &L){
	for(int i = 0; i< L.MaxSize;i++){
        L.data[i] = 0;
    }
    L.length = 0;
}
```

**2) 动态分配顺序表的初始化**

```C++
//初始化顺序表
void InitList(SeqList &L){
    L.data = new ElemType[INITSIZE];//申请初始空间
    if(!L.data)//如果申请失败，结束程序
        eixt(OVERFLOW);
    L.MaxSize = INITSIZE;
    L.length = 0;
}
```

**3) 动态分配长度顺序表增加表长**

```C++
void IncreaseSjze(SeqList &L,int len){
    ElemType *p = L.data;
    L.data = new ElemType[L.MaxSize+len];//重新申请更大的空间
    for(int i = 0; i<L.lenth;i++){
        L.data[i] = p[i];//将数据复制到新的空间
    }
    L.MaxSize += len;//顺序表长度增加 len
    delete(p);//释放原来的内存空间
}
```

### 2.2 顺序表的插入和删除

#### 2.2.1 顺序表的插入 ListInert

```C++
bool ListInsert(SeqList &L,int i,Elemtype e){
    if(i<i||i>L.length+1)//判断i的范围是否有效
        return false;
    if(L.length>=L.MaxSize)//如果内存空间不够，重新申请空间
        IncreaseSize(L,10);
    for(int j=L.length;j>=i;j--)//将第i个及之后的元素依次后移
        L.data[j] = L.data[j-1];
    L.data[i-1] = e;//在第i个位置出插入元素e
    L.length++;//顺序表长度加1
    return true;
}
```

**时间复杂度：**

最好情况：新元素插到表位，不需要移动元素，循环0次，==最好时间复杂度=O(1)==

最坏情况：新元素插到表头，移动n个元素，循环n次，==最坏时间复杂度=O(n)==

平均情况：插入每个位置的概率相等，为p=$\frac{1}{1+n}$，平均循环次数=$\frac{0+1+2+...+n}{1+n}=\frac{n}{2}$，==平均时间复杂度=O(n)==

#### 2.2.2 顺序表的删除操作 ListDelete

```C++
bool ListDelete(SeqList &L,int i,Elemtype &e){
    if(i<1||i>L.length)//判断i的范围是否合格
        return false;
    e = L.data[i-1];//返回位置i元素
    for(int j = i;j<L.length;j++)//第i个及之后的元素以此前移
        L.data[j-1] = L.data[j];
    L.length--;//顺序表长度减1
    return true;
}
```

**时间复杂度：**

最好情况：删除表尾元素，不需要移动其他元素，循环0次，==最好时间复杂度=O(1)==

最坏情况：删除表头元素，移动后续n-1个元素，循环n-1次，==最坏时间复杂度=O(n)==

平均情况：删除每个元素的概率相等，为p=$\frac{1}{n}$，平均循环次数=$\frac{0+1+...+(n-1)}{n}=\frac{n-1}{2}$，==平均时间复杂度=O(n)==

### 2.3 顺序表的查找

#### 2.3.1 按位查找(GetElem)

```C++
//获取表L中第i个位置的元素的值
//通过数组下标直接获取
ElemType getElem(SeqList L,int i){
    
    return L.data[i-1];
}
```

**时间复杂度=**O(1)

#### 2.3.2 按值查找(LocateElem)

```C++
//在顺序表L中查找第一个元素值等于e的元素，并返回其位序
//从第一个元素一次往后检索（从头遍历）
int LocateElem(SeqList L,ElemType e){
    for(int i = 0;i<L.length;i++)
        if(L.data[i]==e)
            return i+1;//数组下标为i的元素值等于e，返回其位序i+1
    return 0;//退出循环，说明查找失败
}
```

**时间复杂度：**

最好情况：目标元素在表头，循环1次，==最好时间复杂度=O(1)==

最坏情况：目标元素在表尾，循环n次，==最坏时间复杂度=O(n)==

平均情况：目标元素出现的概率相同，为p=$\frac{1}{n}$，平均循环次数=$\frac{1+2+...+n}{n}=\frac{1+n}{2}$，==平均时间复杂度=O(n)==

### 2.4 顺序表基本操作全部实现

```C++
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define INITSIZE 10
typedef int Status;
typedef int ElemType;
//结构体
typedef struct {
    ElemType *data;
    int MaxSize;
    int length;
} SeqList;
//初始化顺序表
Status InitList(SeqList &L) {
    L.data = new ElemType[INITSIZE];
    if (!L.data)
        exit(OVERFLOW);
    L.MaxSize = INITSIZE;
    L.length = 0;
    return OK;
}
//销毁顺序表
Status DestroyList(SeqList &L) {
    delete (L.data);
    L.MaxSize = 0;
    L.length = 0;
    return OK;
}
//增加表长
Status IncreaseList(SeqList &L, int len) {
    int *p = L.data;
    L.data = new ElemType[L.MaxSize + len];
    if (!L.data)
        exit(OVERFLOW);
    for (int i = 0; i < L.length; i++)
        L.data[i] = p[i];
    L.MaxSize += len;
    return OK;
}
//判空
bool ListEmpty(SeqList L) {
    if (L.length == 0)
        return true;
    else
        return false;
}
//清空顺序表
Status ClearList(SeqList &L) {
    L.length = 0;
    return OK;
}
//按位插入
Status ListInsert(SeqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1)
        return ERROR;
    if (L.length == L.MaxSize)
        return ERROR;
    for (int j = L.length; j >= i; j--)
        L.data[j] = L.data[j - 1];
    L.data[i - 1] = e;
    L.length++;
    return OK;
}
//按位删除
Status ListDelete(SeqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length)
        return 0;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++)
        L.data[j - 1] = L.data[j];
    L.length--;
    return OK;
}
//按位查找
ElemType GetElem(SeqList L, int i) {
    if (i < 1 || i > L.length)
        exit(OVERFLOW);
    return L.data[i - 1];
}
//按值查找，返回其位序
int LocateElem(SeqList L, ElemType e) {
    for (int i = 0; i < L.length; i++)
        if (L.data[i] == e)
            return i;
    return 0;
}
```

##  2 单链表

### 2.1 单链表的定义

**单链表：**线性表的链式存储，它是指通过一组任意的存储单元来存储线性表中的数据元素。

**优点：**不要求大片连续空间，改变容量方便

**缺点：**不可随机存取，要耗费一定空间存放指针

**结点：**

```C++
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
```

![img](数据结构.assets\image-20220810210709933.png)

**定义辨析：**

1.  头指针：指向链表中第一个结点的指针
2.  头节点：在首元结点之前的一个节点，不存放数据，其指针域指向首元结点
3.  首元结点：链表中存储第一个数据元素的结点

![img](数据结构.assets/image-20220810210559745.png)

#### 2.1.1 不带头结点的单链表

**初始化单链表：**

```C++
//初始化单链表
bool InitList(LinkList &L) {
    L = nullptr;//表空，暂时没有任何结点，防止头指针的地址原来有脏数据
    return true;
}
```

**判断表空：**

```C++
//判断单链表是否为空
bool Empty(LinkList L) {
    if (!L)
        return true;
    else
        return false;
}
```

#### 2.1.2 带头结点的单链表

```C++
//初始化单链表
bool InitList(LinkList &L) {
    L = new LNode;//申请头结点
    if (!L)//空间申请失败
        return false;
    L->next = nullptr;
    return true;
}
```

**判断表空：**

```C++
//判断单链表是否为空
bool Empty(LinkList L) {
    return (L->next == nullptr);
}
```

### 2.2单链表的插入

#### 2.2.1 单链表的按位插入

**带头结点：**

```C++
//按位序插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    LNode *p = L;//指向头结点，头结点是第0个结点
    int j = 0;//计数器,p指向的第几个结点
    while (p && j < i - 1) {//循环找到第i-1个结点或到表尾
        p = p->next;
        ++j;
    }
    if (!p)//p指针为空，也就是i值不合法，i>单链表长度
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;//s插到p之后
    return true;
}
```

**时间复杂度：**O(n)

**不带头节点：**

```C++
//按位插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    if (i == 1) {//插入第1个结点
        LNode *s = new LNode;
        s->data = e;
        s->next = nullptr;
        L = s;
        return true;
    }
    //插入第2个及之后的结点
    int j = 1;
    LNode *p = L;
    while (p && j < i - 1) {//i>n
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

#### 2.2.2 指定结点后插入结点

**方法：**

1.  判断给定结点p不为空
2.  创建新结点s，并将给定值e赋给结点s
3.  s结点插入到结点p之后

```C++
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

**时间复杂度：**O(1)

#### 2.2.3 指定结点前插入结点

**方法：**

1.  判断给定结点p不为空
2.  创建新结点s，并将结点p的数据元素复制到结点s
3.  将结点s插入到结点p之后
4.  将要插入的元素e赋给结点p

```C++
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;
}
```

**时间复杂度：**O(1)

### 2.3 单链表的删除

#### 2.3.1 按位序删除

**带头结点：**

**方法：**

1.  扫描到第i-1个结点
2.  保存第i个结点
3.  删除第i个结点
4.  释放第i个结点内存空间

```C++
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//p指向头结点，也就是第0个结点
    int j = 0;//计数器，p指向第几个结点
    while (p && j < i - 1) {//扫描到第i-1个结点，或者扫描到表尾
        p = p->next;
        ++j;
    }
    if (!p)//i值不合格,i>表长，扫描全表不存在p
        return false;
    LNode *q = p->next;//保存要删除的结点
    e = q->data;//e存放要删除结点的元素值
    p->next = q->next;//删除结点
    delete (q);//释放删除结点的内存空间
    return true;
}
```

**时间复杂度：**

最好时间复杂度 = O(1)
最坏、平均时间复杂度 = O(n)

按位序删除操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

#### 2.3.2 指定节点的删除

```C++
//指定节点的删除(给定结点不为表尾结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete (q);
}
```

### 2.4 单链表的查找

#### 2.4.1 按位查找

```C++
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    return p;
}
```

按位查找操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

#### 2.4.2 按值查找

**带头结点：**

```C++
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;//从首元结点开始查找
    while (p && p->data != e) {
        p = p->next;
    }
    return p;//如果找到了就返回结点指针，没找到就返回空指针
}
```

**时间复杂度=O(n)**

**不带头结点：**

```C++
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}
```

### 2.5 求表长

```C++
//求表长
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while (p->next) {
        p = p->next;
        len++;
    }
    return len;
}
```

**时间复杂度=O(n)**

求表长操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

### 2.6 单链表的建立

#### 2.6.1 尾插法

**步骤：**

1.  初始化单链表
2.  保存表尾结点
3.  while 循环插入结点

##### 1) 带头结点

```C++
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    L = new LNode;//建立头结点，这样就直接进行了初始化操作
    LNode *s, *r = L;//r为表尾结点
    cin >> x;//输入第一个结点的值
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//r移到新的表尾结点
        cin >> x;
    }
    r->next = nullptr;//表尾指针置空
    return L;
}
```

##### 2) 不带头结点

```C++
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    cin >> x;
    L = new LNode;
    L->data = x;
    LNode *r, *s;
    r = L;//尾指针
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//指向表尾结点
        cin >> x;
    }
    delete s;
    r->next = nullptr;
    return L;
}
```

不带头结点的是我自己写的，带头结点和不到头结点的区别是：不带头结点需要先插入首元结点，在进行循环插入；而带头结点可以直接进行循环插入。

#### 2.6.2 头插法

##### 1) 带头结点：

```C++
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    L = new LNode;//建立头结点
    LNode *s;
    L->next = nullptr;//表尾指针置空
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L->next;//s插入到表头
        L->next = s;//头结点指向首元结点
        cin >> x;
    }
    return L;
}
```

**重要应用：链表的逆置**

##### 2) 不带头结点：

```C++
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    LNode *s;
    L = nullptr;
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L;
        L = s;
        cin >> x;
    }
    return L;
}
```

### 2.7 单链表的逆置（头插法思想）

#### 1) 带头结点

```C++
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L->next;
    L->next = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L->next;
        L->next = q;
    }
}
```

#### 2) 不带头结点

```C++
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L;
    L = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L;
        L = q;
    }
}
```

### 2.8 全部操作的实现

#### 1) 带头结点

```C++
typedef int ElemType;
//定义结点
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
//初始化单链表
bool InitList(LinkList &L) {
    L = new LNode;//申请头结点
    if (!L)//空间申请失败
        return false;
    L->next = nullptr;
    return true;
}
//判断表空
bool Empty(LinkList L) {
    return (L->next == nullptr);
}
//按位序插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    LNode *p = L;//指向头结点，头结点是第0个结点
    int j = 0;//计数器,p指向的第几个结点
    while (p && j < i - 1) {//循环找到第i-1个结点或到表尾
        p = p->next;
        ++j;
    }
    if (!p)//p指针为空，也就是i值不合法，i>单链表长度
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;//s插到p之后
    return true;
}
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;
}
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//p指向头结点，也就是第0个结点
    int j = 0;//计数器，p指向第几个结点
    while (p && j < i - 1) {//扫描到第i-1个结点，或者扫描到表尾
        p = p->next;
        ++j;
    }
    if (!p)//i值不合格,i>表长，扫描全表不存在p
        return false;
    LNode *q = p->next;//保存要删除的结点
    e = q->data;//e存放要删除结点的元素值
    p->next = q->next;//删除结点
    delete q;//释放删除结点的内存空间
    return true;
}
//指定节点的删除(给定结点不为最后结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete q;
    return true;
}
//按位查找，获取表中第i个位置的元素的值
bool GetElem(LinkList L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    e = p->data;
    return true;
}
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    return p;
}
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;//从首元结点开始查找
    while (p && p->data != e) {
        p = p->next;
    }
    return p;//如果找到了就返回结点指针，没找到就返回空指针
}
//求表长
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while (p->next) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    L = new LNode;
    LNode *s, *r = L;//r为表尾结点
    cin >> x;//输入第一个结点的值
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//r移到新的表尾结点
        cin >> x;
    }
    delete s;
    r->next = nullptr;//表尾指针置空
    return L;
}
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    L = new LNode;//建立头结点
    LNode *s;
    L->next = nullptr;//表尾指针置空
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L->next;//s插入到表头
        L->next = s;//头结点指向首元结点
        cin >> x;
    }
    return L;
}
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L->next;
    L->next = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L->next;
        L->next = q;

    }
}
```

#### 2) 不带头结点

```C++
typedef int ElemType;
//定义结点
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
//初始化链表
bool InitList(LinkList &L) {
    L = nullptr;//表空，暂时没有任何结点，防止头指针的地址原来有脏数据
    return true;
}
//判断表空（无头结点）
bool Empty(LinkList L) {
    if (!L)
        return true;
    else
        return false;
}
//按位插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    if (i == 1) {//插入第1个结点
        LNode *s = new LNode;
        s->data = e;
        s->next = nullptr;
        L = s;
        return true;
    }
    //插入第2个及之后的结点
    int j = 1;
    LNode *p = L;
    while (p && j < i - 1) {//i>n
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (!p)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (!p)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;

}
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//首元结点
    int j = 1;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p)
        return false;
    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    delete q;
    return true;
}
//指定节点的删除(给定结点不为最后结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete q;
    return true;

}
//按位查找，获取表中第i个位置的元素的值
bool GetElem(LinkList L, int i, ElemType &e) {
    if (i < 1)
        return false;
    int j = 1;
    LNode *p = L;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    if (!p)
        return false;
    e = p->data;
    return true;
}
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}
//求表长
int Length(LinkList L) {
    LNode *p = L;
    int len = 1;
    while (!p->next) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    cin >> x;
    L = new LNode;
    L->data = x;
    LNode *r, *s;
    r = L;//尾指针
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//指向表尾结点
        cin >> x;
    }
    delete s;
    r->next = nullptr;
    return L;
}
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    LNode *s;
    L = nullptr;
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L;
        L = s;
        cin >> x;
    }
    return L;
}
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L;
    L = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L;
        L = q;
    }
}
```

## 3 双向链表

### 3.1 结点

![img](数据结构.assets/v2-afd5989520263063e49eae8b76328061_720w.png)

```C++
typedef struct DNode {
    ElemType data;
    struct DNode *prior;//前指针
    struct DNode *next;//后指针
} DNode, *DLinkList;
```

### 3.2 初始化

```C++
bool initList(DLinkList &L) {
    L = new DNode;//头结点
    if (!L)
        return false;
    L->prior = nullptr;//头结点prior指向空
    L->next = nullptr;
    return true;
}
```

### 3.3 判空

```C++
bool empty(DLinkList L) {
    if (!L->next)
        return false;
    else
        return true;
}
```

### 3.4 插入结点

```C++
//在p结点后插入s结点
bool insert_next_node(DNode *p, DNode *s) {
    if (!p || !s)
        return false;
    s->next = p->next;
    if (p->next)//如果p结点有后继节点
        p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
```

### 3.5 删除结点

```C++
//删除结点p的后继节点
bool delete_next_node(DNode *p) {
    if (!p || !p->next)
        return false;
    DNode *q = p->next;
    p->next = q->next;
    if (q->next)
        q->next->prior = p;
    delete q;
    return true;
}
```

### 3.6 按位查找

```C++
//按位查找，返回第i个结点
DNode *get_elem(DLinkList &L, int i) {
    if (!L)
        return nullptr;
    int j = 1;
    DNode *p = L->next;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}
```

### 3.7 后插法

```C++
bool insert_tail_list(DLinkList &L) {
    if (!L)
        return false;
    L = new  DNode;
    L->prior= nullptr;
    ElemType x;
    DNode *p, *s;
    p = L;
    if (!p)
        return false;
    cin >> x;
    while (x != 9999) {
        s = new DNode;
        s->data = x;
        s->prior = p;
        p->next = s;
        p = s;
        cin >> x;
    }
    p->next = nullptr;
    return true;
}
```

### 3.8 遍历

#### 1） 后向遍历

```C++
//后向遍历打印双链表
void next_to_string(DLinkList L) {
    if (!L)
        exit(-1);
    cout << "打印双链表：";
    DNode *p = L->next;//首元结点
    while (p) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}
```

#### 2） 前向遍历

```C++
//前向遍历打印链表
void prior_to_string(DNode *p){//p为表中最后一个结点
    cout << "前项遍历链表：";
    while(p->prior){//p->prior为空表示当前p已经指向头指针
        cout << p->data << " ";
        p=p->prior;
    }
    cout << endl;
}
```

时间复杂度=O(n)

## 4  循环链表

### 4.1 循环单链表

**特点：**

1.  表尾指针的next指向头结点
2.  从一个节点出发，可以找到其他任何一个结点。

#### 1）初始化

```
bool init_list(LinkList &L) {
    L = new LNode;
    if (!L)
        return false;
    L->next = L;
    return true;
}
```

#### 2）判空

```C++
bool empty(LinkList L) {
    if (L->next == L)
        return true;
    else
        return false;
}
```

#### 3）判断结点是否是表尾结点

```C++
bool is_tail(LinkList L, LNode *p) {
    if (p->next == L)
        return true;
    else
        return false;
}
```

### 4.2 循环双链表

**特点：**

1.  表头指针prior指向表尾结点
2.  表尾指针的next指向头结点

#### 1）初始化

```C++
bool init_list(DLinkList &L) {
    L = new DNode;
    if (!L)
        return false;
    L->prior = L;
    L->next = L;
    return true;
}
```

#### 2）判空

```C+=
bool empty(DLinkList L) {
    if (L->next == L)
        return true;
    else
        return false;
}
```

#### 3）判断结点是否为表尾结点

```C++
bool is_tail(DLinkList L, DNode *p) {
    if (p->next == L)
        return true;
    else
        return false;
}
```

#### 4）插入

```C++
//结点p后插入元素值为e的结点
bool insert_next_node(DNode *p, ElemType e) {
    if (!p)
        return false;
    DNode *s = new DNode;
    s->data = e;
    s->next = p->next;
    if (p->next)
        p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
```

#### 5）删除

```C++
//删除结点p后的结点
bool delete_next_node(DNode *p) {
    if (!p || !p->next)
        return false;
    DNode *q = p->next;
    p->next = q->next;
    if (q->next)
        q->next->prior = p;
    delete q;
    return true;
}
```

#### 6）获取结点

```C++
//获取第i个结点
DNode *get_elem(DLinkList L, int i) {
    if (i < 1 || !L)
        return nullptr;
    DNode *p = L->next;
    int j = 1;
    while (p != L && j < i) {
        p = p->next;
        j++;
    }
    if (p == L)
        return nullptr;
    return p;
}
```

## 5 静态链表（不一定考）

**特点：**分配一整片连续的内存空间，各个结点集中安置

**优点：**增删操作不需要大量移动元素

**缺点：**不能随机存取，只能从头结点开始依次往后查找；==容量固定不可变==

**使用场景：**1）不支持指针的低级语言；2）数据元素数量固定不变的场景(如操作系统的文件分配表FAT)

![image-20220817153449287](数据结构.assets/image-20220817153449287.png)  

**结点：**

```C++
struct Node{
    ElemType data;
    int next;//游标，充当指针，指向下一个元素的数组下标
};
struct Node node[MAX_SIZE];//初始化
//或者
typedef struct{
    ElemType data;
    int next;
}SLinkList[MAX_SIZE];
SLinkList sLinkList;//初始化
```



### 1）查找

从头结点出发挨个往后遍历

时间复杂度=O(n)

### 2）插入位序为i的结点

1.  找到一个空的结点，存入数据
2.  从头结点出发找到位序为i-1的结点
3.  修改新结点的next
4.  修改i-1号结点的next

### 3）删除某个结点

1.  从头结点出发找到前驱结点
2.  修改前驱节点的游标
3.  被删除结点next设置为-2(设置为-2只是为了表示next为空)

## 6 顺序表和链表的对比

### 1）逻辑结构

都属于线性表，都是线性结构

### 2）存储结构

**顺序表：**采用==顺序存储==，逻辑上相邻的元素，对应的物理存储位置也相邻

1.  优点：支持随机存取，存储密度高
2.  缺点：大片连续空间分配不方便，改变容量不方便，会出现空间闲置或溢出的现象

**链表：**采用==链式存储==，逻辑上相邻的元素，物理存储位置不一定相邻

1.  优点：理想的小空间分配方便，改变容量方便，不会出现空间闲置或溢出现象
2.  缺点：不可随机存取，存储密度低

### 3）基本操作

**创建操作：**

-   顺序表
    -   静态分配，需要与分配一大块连续的内存空间，会造成浪费或溢出，容量不可改变。
    -   也可采用动态分配，容量可以改变，但是需要移动大量的元素，时间代价高
-   链表：动态分配，只需要先申请一个头结点，容量可改变

**销毁操作：**

-   顺序表：系统自动回收内存空间
-   链表：需要手动申请和释放内存

**插入、删除操作：**

-   顺序表：
    -   插入/删除元素需要将后续元素都后移/前移
    -   时间复杂度O(n)，时间开销主要来自移动元素
-   链表：
    -   插入/删除元素只需要修改指针即可
    -   时间复杂度O(n)，时间开销主要来自查找目标元素

**查找操作：**

-   顺序表：
    -   按位查找：O(1)
    -   按值查找：O(n)，若表内有序可采用折半查找，时间复杂度O(log~2~n)
-   链表：
    -   按位查找：O(n)
    -   按值查找：O(n)

### 4）顺序表和链表的选择

|                | 顺序表 | 链表 |
| :------------: | :----: | :--: |
| 弹性（可扩容） |   ×    |  √   |
|     增、删     |   ×    |  √   |
|       查       |   √    |  ×   |

## 7 线性表的应用

### 7.1 线性表的合并

**步骤：**

1.  分别获取LA表长m、LB表长n
2.  遍历LB表，如果表中元素不在A中，插入到LA表后

```C++
//顺序表为例
void merge_list(SeqList &s1,SeqList &s2){
    int m=Length(s1);
    int n=Length(s2);
    for (int i = 0; i < n; i++) {
        ElemType x = s2.GetElem(s2,i+1);
        if(!LocateElem(s1,x))
            ListInsert(s1,++m,x);
    }
}
```

**时间复杂度=O(m*n)**，顺序表和链表都是。

### 7.2 有序表的合并

#### 1）有序顺序表的合并

```C++
void merge_list_seq(SeqList LA, SeqList LB, SeqList &LC) {
    if ((LA.length + LB.length) > LC.MaxSize)
        LC.IncreaseList(LA.length + LB.length - LC.length);//扩展LC的容量
    int a = 0, b = 0, c = 0;
    while (a < LA.length && b < LB.length) {//遍历LA和LB
        if (LA.data[a] <= LB.data[b])//两两相比，把小的那个元素插入到LC表
            LC.data[c++] = LA.data[a++];
        else
            LC.data[c++] = LB.data[b++];
    }
    while (a < LA.length)//如果LA表还有剩余元素，插入到LC表中
        LC.data[c++] = LA.data[a++];
    while (b < LB.length)//如果LB表还有剩余元素，插入到LC表中
        LC.data[c++] = LB.data[b++];
    LC.length = c;
}
```

