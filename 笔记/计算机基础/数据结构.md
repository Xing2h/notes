一、数据结构和算法

# 二、线性表

## 1 线性表的定义和基本操作

### 1.1 线性表的定义

线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。

若用L命名线性表，则其一般表示为 L=（a~1~,a~2~,···,a~i~,a~I+1~,···,a~n~）,式中a~1~是唯一的“第一个”数据元素，又称表头元素；

a~n~是唯一个个"最后一个"数据元素，又称表尾元素。

除第一个元素外，每个数据元素有且仅有一个直接前驱；除最后一个元素外，每个数据元素有且仅有一个直接后继。

### 1.2 线性表的特点

-   表中元素的个数有限。
-   表中元素的都具有逻辑上的顺序性，表中元素有其先后次序。
-   表中元素都是数据元素，每个元素都是单个元素。
-   表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
-   表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。

### 1.3 线性表的抽象数据类型ADT

```C++
ADT List{
数据对象：D={ai|ai=ElemSet,i=1,2,..,n,n≥0}
数据关系：R={<ai-1,ai>|ai-1,ai∈D,i=2,...,n}
基本操作：
IniList(&L)
	操作结果：构造一个空的线性表L。
DestroyList(&L)
    初始条件：线性表L已存在
	操作结果：销毁线性表L
ClearList(&L)
    初始条件：线性表L已存在
	操作结果：将L重置为空表
ListEmpty(L)
    初始条件：线性表L已存在
	操作结果：若L为空表，则返回true，否则返回false
ListLength(L)
    初始条件：线性表L已存在
	操作结果：返回L中数据元素个数
GetElem(L,i,&e)
	初始条件：线性表L已存在，1≤i≤ListLength(L)   
	操作结果：用e返回L中第i个数据元素的值
LocateElem(L,e,compare())
    初始条件：线性表L已存在
	操作结果：返回L中第一个值与e相同的数据元素在L中的位置。若这样的数据元素不存在，则返回值为0.
PriorElem(L,cur_e,&pre_e)
    初始条件：线性表L已存在
	操作结果：若cur-e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义
NextElem(L,cur_e,&next_e)
    初始条件：线性表L已存在
	操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义
ListInsert(&L,i,e)
	初始条件：线性表已存在，1≤i≤ListLength(L)+1
	操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1
ListDelete(&L,i,&e)
	初始条件： 线性表存在且非空，1≤i≤ListLength(L)
	操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
TravarseList(L)
    初始条件：线性表已存在
	操作结果：依次对线性表L进行遍历，在遍历过程中对L的每个结点访问一次
}ADT List
```

### 1.4 线性表基本操作

```C++
InitList(&L)：初始化表。构造一个空表L，分配内存空间。
DestroyList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。
ListInsert(&L,i,e)：插入操作。在表L中第i个位置上插入指定元素e。
ListDelete(&L,i,&e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。
LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。
GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。
Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。
PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素的值。
Empty(L)：判空操作。若L为空表，则返回true，否则返回false。
```

## 2 顺序表

### 2.1 顺序表的定义

**顺序表的存储结构：**顺序存储，即逻辑上相邻的数据元素在物理上也相邻

**顺序表的特点：**

1.  ==随机存取==，即可以在O(1)时间内找到第i个元素
2.  存储密度高，每个节点只存储数据元素
3.  拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
4.  插入、删除操作不方便，需要移动大量元素

**优点：**可随机存取，存储密度高

**缺点：**需要大片连续的空间，改变容量不方便

#### 2.1.1 顺序表的实现方式

**顺序表有两种实现方式：**

1.  静态分配
    -   使用"静态数组"实现，大小一旦确定就无法改变
2.  动态分配
    -   使用"动态数组"实现
    -   顺序表满时，可以再用new关键字重新申请更大的内存空间来拓展顺序表的最大长度
    -   需要将数据元素复制到新的存储空间，并用delete关键字释放原来的空间

```C++
//静态分配的顺序表（大小一旦确定就无法改变）
#define MAXSIZE 10//线性表的最大长度
typedef struct{
	ElemType data[MAXSIZE];
    int length;
}SqList;
//动态分配的顺序表（使用动态数组实现）
#define INITSIZE 10//顺序表的初始长度
typedef struct{
    ElemType *data;//指示动态分配数组的指针
    int MaxSize;//顺序表的最大容量
    int length;//顺序表当前的长度
}SeqList;
```

#### 2.1.2 初始化顺序表 InitList

**1) 静态分配顺序表**

```C++
//初始化顺序表（固定长度，不设置默认值）
void InitList(SqList &L){
    L.length = 0;
}
//初始化顺序表（固定长度，设置默认值）
void InitList(SqList &L){
	for(int i = 0; i< L.MaxSize;i++){
        L.data[i] = 0;
    }
    L.length = 0;
}
```

**2) 动态分配顺序表的初始化**

```C++
//初始化顺序表
void InitList(SeqList &L){
    L.data = new ElemType[INITSIZE];//申请初始空间
    if(!L.data)//如果申请失败，结束程序
        eixt(OVERFLOW);
    L.MaxSize = INITSIZE;
    L.length = 0;
}
```

**3) 动态分配长度顺序表增加表长**

```C++
void IncreaseSjze(SeqList &L,int len){
    ElemType *p = L.data;
    L.data = new ElemType[L.MaxSize+len];//重新申请更大的空间
    for(int i = 0; i<L.lenth;i++){
        L.data[i] = p[i];//将数据复制到新的空间
    }
    L.MaxSize += len;//顺序表长度增加 len
    delete(p);//释放原来的内存空间
}
```

### 2.2 顺序表的插入和删除

#### 2.2.1 顺序表的插入 ListInert

```C++
bool ListInsert(SeqList &L,int i,Elemtype e){
    if(i<i||i>L.length+1)//判断i的范围是否有效
        return false;
    if(L.length>=L.MaxSize)//如果内存空间不够，重新申请空间
        IncreaseSize(L,10);
    for(int j=L.length;j>=i;j--)//将第i个及之后的元素依次后移
        L.data[j] = L.data[j-1];
    L.data[i-1] = e;//在第i个位置出插入元素e
    L.length++;//顺序表长度加1
    return true;
}
```

**时间复杂度：**

最好情况：新元素插到表位，不需要移动元素，循环0次，==最好时间复杂度=O(1)==

最坏情况：新元素插到表头，移动n个元素，循环n次，==最坏时间复杂度=O(n)==

平均情况：插入每个位置的概率相等，为p=$\frac{1}{1+n}$，平均循环次数=$\frac{0+1+2+...+n}{1+n}=\frac{n}{2}$，==平均时间复杂度=O(n)==

#### 2.2.2 顺序表的删除操作 ListDelete

```C++
bool ListDelete(SeqList &L,int i,Elemtype &e){
    if(i<1||i>L.length)//判断i的范围是否合格
        return false;
    e = L.data[i-1];//返回位置i元素
    for(int j = i;j<L.length;j++)//第i个及之后的元素以此前移
        L.data[j-1] = L.data[j];
    L.length--;//顺序表长度减1
    return true;
}
```

**时间复杂度：**

最好情况：删除表尾元素，不需要移动其他元素，循环0次，==最好时间复杂度=O(1)==

最坏情况：删除表头元素，移动后续n-1个元素，循环n-1次，==最坏时间复杂度=O(n)==

平均情况：删除每个元素的概率相等，为p=$\frac{1}{n}$，平均循环次数=$\frac{0+1+...+(n-1)}{n}=\frac{n-1}{2}$，==平均时间复杂度=O(n)==

### 2.3 顺序表的查找

#### 2.3.1 按位查找(GetElem)

```C++
//获取表L中第i个位置的元素的值
//通过数组下标直接获取
ElemType getElem(SeqList L,int i){
    
    return L.data[i-1];
}
```

**时间复杂度=**O(1)

#### 2.3.2 按值查找(LocateElem)

```C++
//在顺序表L中查找第一个元素值等于e的元素，并返回其位序
//从第一个元素一次往后检索（从头遍历）
int LocateElem(SeqList L,ElemType e){
    for(int i = 0;i<L.length;i++)
        if(L.data[i]==e)
            return i+1;//数组下标为i的元素值等于e，返回其位序i+1
    return 0;//退出循环，说明查找失败
}
```

**时间复杂度：**

最好情况：目标元素在表头，循环1次，==最好时间复杂度=O(1)==

最坏情况：目标元素在表尾，循环n次，==最坏时间复杂度=O(n)==

平均情况：目标元素出现的概率相同，为p=$\frac{1}{n}$，平均循环次数=$\frac{1+2+...+n}{n}=\frac{1+n}{2}$，==平均时间复杂度=O(n)==

### 2.4 顺序表基本操作全部实现

```C++
#define OK 1
#define ERROR 0
#define OVERFLOW -2
#define INITSIZE 10
typedef int Status;
typedef int ElemType;
//结构体
typedef struct {
    ElemType *data;
    int MaxSize;
    int length;
} SeqList;
//初始化顺序表
Status InitList(SeqList &L) {
    L.data = new ElemType[INITSIZE];
    if (!L.data)
        exit(OVERFLOW);
    L.MaxSize = INITSIZE;
    L.length = 0;
    return OK;
}
//销毁顺序表
Status DestroyList(SeqList &L) {
    delete (L.data);
    L.MaxSize = 0;
    L.length = 0;
    return OK;
}
//增加表长
Status IncreaseList(SeqList &L, int len) {
    int *p = L.data;
    L.data = new ElemType[L.MaxSize + len];
    if (!L.data)
        exit(OVERFLOW);
    for (int i = 0; i < L.length; i++)
        L.data[i] = p[i];
    L.MaxSize += len;
    return OK;
}
//判空
bool ListEmpty(SeqList L) {
    if (L.length == 0)
        return true;
    else
        return false;
}
//清空顺序表
Status ClearList(SeqList &L) {
    L.length = 0;
    return OK;
}
//按位插入
Status ListInsert(SeqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1)
        return ERROR;
    if (L.length == L.MaxSize)
        return ERROR;
    for (int j = L.length; j >= i; j--)
        L.data[j] = L.data[j - 1];
    L.data[i - 1] = e;
    L.length++;
    return OK;
}
//按位删除
Status ListDelete(SeqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length)
        return 0;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j++)
        L.data[j - 1] = L.data[j];
    L.length--;
    return OK;
}
//按位查找
ElemType GetElem(SeqList L, int i) {
    if (i < 1 || i > L.length)
        exit(OVERFLOW);
    return L.data[i - 1];
}
//按值查找，返回其位序
int LocateElem(SeqList L, ElemType e) {
    for (int i = 0; i < L.length; i++)
        if (L.data[i] == e)
            return i;
    return 0;
}
```

##  2 单链表

### 2.1 单链表的定义

**单链表：**线性表的链式存储，它是指通过一组任意的存储单元来存储线性表中的数据元素。

**优点：**不要求大片连续空间，改变容量方便

**缺点：**不可随机存取，要耗费一定空间存放指针

**结点：**

```C++
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
```

![image-20220810210709933](数据结构.assets/image-20220810210709933.png)

**定义辨析：**

1.  头指针：指向链表中第一个结点的指针
2.  头节点：在首元结点之前的一个节点，不存放数据，其指针域指向首元结点
3.  首元结点：链表中存储第一个数据元素的结点

![img](数据结构.assets/image-20220810210559745.png)

#### 2.1.1 不带头结点的单链表

**初始化单链表：**

```C++
//初始化单链表
bool InitList(LinkList &L) {
    L = nullptr;//表空，暂时没有任何结点，防止头指针的地址原来有脏数据
    return true;
}
```

**判断表空：**

```C++
//判断单链表是否为空
bool Empty(LinkList L) {
    if (!L)
        return true;
    else
        return false;
}
```

#### 2.1.2 带头结点的单链表

```C++
//初始化单链表
bool InitList(LinkList &L) {
    L = new LNode;//申请头结点
    if (!L)//空间申请失败
        return false;
    L->next = nullptr;
    return true;
}
```

**判断表空：**

```C++
//判断单链表是否为空
bool Empty(LinkList L) {
    return (L->next == nullptr);
}
```

### 2.2单链表的插入

#### 2.2.1 单链表的按位插入

**带头结点：**

```C++
//按位序插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    LNode *p = L;//指向头结点，头结点是第0个结点
    int j = 0;//计数器,p指向的第几个结点
    while (p && j < i - 1) {//循环找到第i-1个结点或到表尾
        p = p->next;
        ++j;
    }
    if (!p)//p指针为空，也就是i值不合法，i>单链表长度
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;//s插到p之后
    return true;
}
```

**时间复杂度：**O(n)

**不带头节点：**

```C++
//按位插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    if (i == 1) {//插入第1个结点
        LNode *s = new LNode;
        s->data = e;
        s->next = nullptr;
        L = s;
        return true;
    }
    //插入第2个及之后的结点
    int j = 1;
    LNode *p = L;
    while (p && j < i - 1) {//i>n
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

#### 2.2.2 指定结点后插入结点

**方法：**

1.  判断给定结点p不为空
2.  创建新结点s，并将给定值e赋给结点s
3.  s结点插入到结点p之后

```C++
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

**时间复杂度：**O(1)

#### 2.2.3 指定结点前插入结点

**方法：**

1.  判断给定结点p不为空
2.  创建新结点s，并将结点p的数据元素复制到结点s
3.  将结点s插入到结点p之后
4.  将要插入的元素e赋给结点p

```C++
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;
}
```

**时间复杂度：**O(1)

### 2.3 单链表的删除

#### 2.3.1 按位序删除

**带头结点：**

**方法：**

1.  扫描到第i-1个结点
2.  保存第i个结点
3.  删除第i个结点
4.  释放第i个结点内存空间

```C++
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//p指向头结点，也就是第0个结点
    int j = 0;//计数器，p指向第几个结点
    while (p && j < i - 1) {//扫描到第i-1个结点，或者扫描到表尾
        p = p->next;
        ++j;
    }
    if (!p)//i值不合格,i>表长，扫描全表不存在p
        return false;
    LNode *q = p->next;//保存要删除的结点
    e = q->data;//e存放要删除结点的元素值
    p->next = q->next;//删除结点
    delete (q);//释放删除结点的内存空间
    return true;
}
```

**时间复杂度：**

最好时间复杂度 = O(1)
最坏、平均时间复杂度 = O(n)

按位序删除操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

#### 2.3.2 指定节点的删除

```C++
//指定节点的删除(给定结点不为表尾结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete (q);
}
```

### 2.4 单链表的查找

#### 2.4.1 按位查找

```C++
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    return p;
}
```

按位查找操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

#### 2.4.2 按值查找

**带头结点：**

```C++
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;//从首元结点开始查找
    while (p && p->data != e) {
        p = p->next;
    }
    return p;//如果找到了就返回结点指针，没找到就返回空指针
}
```

**时间复杂度=O(n)**

**不带头结点：**

```C++
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}
```

### 2.5 求表长

```C++
//求表长
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while (p->next) {
        p = p->next;
        len++;
    }
    return len;
}
```

**时间复杂度=O(n)**

求表长操作，**带头结点和不带头结点的区别**就在于带头结点==j=0==，不带头结点时==j=1==。

### 2.6 单链表的建立

#### 2.6.1 尾插法

**步骤：**

1.  初始化单链表
2.  保存表尾结点
3.  while 循环插入结点

##### 1) 带头结点

```C++
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    L = new LNode;
    LNode *s, *r = L;//r为表尾结点
    cin >> x;//输入第一个结点的值
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//r移到新的表尾结点
        cin >> x;
    }
    r->next = nullptr;//表尾指针置空
    return L;
}
```

##### 2) 不带头结点

```C++
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    cin >> x;
    L = new LNode;
    L->data = x;
    LNode *r, *s;
    r = L;//尾指针
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//指向表尾结点
        cin >> x;
    }
    r->next = nullptr;
    return L;
}
```

不带头结点的是我自己写的，带头结点和不到头结点的区别是：不带头结点需要先插入首元结点，在进行循环插入；而带头结点可以直接进行循环插入。

#### 2.6.2 头插法

##### 1) 带头结点：

```C++
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    L = new LNode;//建立头结点
    LNode *s;
    L->next = nullptr;//表尾指针置空
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L->next;//s插入到表头
        L->next = s;//头结点指向首元结点
        cin >> x;
    }
    return L;
}
```

**重要应用：链表的逆置**

##### 2) 不带头结点：

```C++
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    LNode *s;
    L = nullptr;
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L;
        L = s;
        cin >> x;
    }
    return L;
}
```

### 2.7 单链表的逆置（头插法思想）

#### 1) 带头结点

```C++
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L->next;
    L->next = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L->next;
        L->next = q;
    }
}
```

#### 2) 不带头结点

```C++
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L;
    L = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L;
        L = q;
    }
}
```

### 2.8 全部操作的实现

#### 1) 带头结点

```C++
typedef int ElemType;
//定义结点
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
//初始化单链表
bool InitList(LinkList &L) {
    L = new LNode;//申请头结点
    if (!L)//空间申请失败
        return false;
    L->next = nullptr;
    return true;
}
//判断表空
bool Empty(LinkList L) {
    return (L->next == nullptr);
}
//按位序插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    LNode *p = L;//指向头结点，头结点是第0个结点
    int j = 0;//计数器,p指向的第几个结点
    while (p && j < i - 1) {//循环找到第i-1个结点或到表尾
        p = p->next;
        ++j;
    }
    if (!p)//p指针为空，也就是i值不合法，i>单链表长度
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;//s插到p之后
    return true;
}
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (p == nullptr)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;
}
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//p指向头结点，也就是第0个结点
    int j = 0;//计数器，p指向第几个结点
    while (p && j < i - 1) {//扫描到第i-1个结点，或者扫描到表尾
        p = p->next;
        ++j;
    }
    if (!p)//i值不合格,i>表长，扫描全表不存在p
        return false;
    LNode *q = p->next;//保存要删除的结点
    e = q->data;//e存放要删除结点的元素值
    p->next = q->next;//删除结点
    delete q;//释放删除结点的内存空间
    return true;
}
//指定节点的删除(给定结点不为最后结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete q;
    return true;
}
//按位查找，获取表中第i个位置的元素的值
bool GetElem(LinkList L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    e = p->data;
    return true;
}
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 0;
    while (p && j < i) {
        p = p->next;
        ++j;
    }
    return p;
}
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;//从首元结点开始查找
    while (p && p->data != e) {
        p = p->next;
    }
    return p;//如果找到了就返回结点指针，没找到就返回空指针
}
//求表长
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while (p->next) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    L = new LNode;
    LNode *s, *r = L;//r为表尾结点
    cin >> x;//输入第一个结点的值
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//r移到新的表尾结点
        cin >> x;
    }
    delete s;
    r->next = nullptr;//表尾指针置空
    return L;
}
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    L = new LNode;//建立头结点
    LNode *s;
    L->next = nullptr;//表尾指针置空
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L->next;//s插入到表头
        L->next = s;//头结点指向首元结点
        cin >> x;
    }
    return L;
}
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L->next;
    L->next = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L->next;
        L->next = q;

    }
}
```

#### 2) 不带头结点

```C++
typedef int ElemType;
//定义结点
typedef struct LNode {
    ElemType data;//数据域,存放数据元素
    struct LNode *next;//指针域，指向下一个结点
} LNode, *LinkList;//LNode表示结点，LinkList表示链表
//初始化链表
bool InitList(LinkList &L) {
    L = nullptr;//表空，暂时没有任何结点，防止头指针的地址原来有脏数据
    return true;
}
//判断表空（无头结点）
bool Empty(LinkList L) {
    if (!L)
        return true;
    else
        return false;
}
//按位插入
bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1)
        return false;
    if (i == 1) {//插入第1个结点
        LNode *s = new LNode;
        s->data = e;
        s->next = nullptr;
        L = s;
        return true;
    }
    //插入第2个及之后的结点
    int j = 1;
    LNode *p = L;
    while (p && j < i - 1) {//i>n
        p = p->next;
        ++j;
    }
    if (!p)
        return false;
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点后插入结点
bool InsertNextNode(LNode *p, ElemType e) {
    if (!p)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定结点前插入结点
bool InsertPriorNode(LNode *p, ElemType e) {
    if (!p)
        return false;
    LNode *s = new LNode;
    if (!s)
        return false;
    s->data = p->data;
    s->next = p->next;
    p->data = e;
    p->next = s;
    return true;

}
//按位序删除
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)
        return false;
    LNode *p = L;//首元结点
    int j = 1;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p)
        return false;
    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    delete q;
    return true;
}
//指定节点的删除(给定结点不为最后结点的情况)
bool DeleteNode(LNode *p) {
    if (!p)
        return false;
    LNode *q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete q;
    return true;

}
//按位查找，获取表中第i个位置的元素的值
bool GetElem(LinkList L, int i, ElemType &e) {
    if (i < 1)
        return false;
    int j = 1;
    LNode *p = L;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    if (!p)
        return false;
    e = p->data;
    return true;
}
//按位查找，返回第i个结点
LNode *GetElem(LinkList L, int i) {
    if (i < 0)
        return nullptr;
    LNode *p = L;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}
//按值查找，在表中查找具有给定关键字值的元素
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}
//求表长
int Length(LinkList L) {
    LNode *p = L;
    int len = 1;
    while (!p->next) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList list_tail_insert(LinkList &L) {
    ElemType x;
    cin >> x;
    L = new LNode;
    L->data = x;
    LNode *r, *s;
    r = L;//尾指针
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        r->next = s;
        r = s;//指向表尾结点
        cin >> x;
    }
    delete s;
    r->next = nullptr;
    return L;
}
//头插法
LinkList list_head_insert(LinkList &L) {
    ElemType x;
    LNode *s;
    L = nullptr;
    cin >> x;
    while (x != 9999) {
        s = new LNode;
        s->data = x;
        s->next = L;
        L = s;
        cin >> x;
    }
    return L;
}
//逆置
void reverse(LinkList &L) {
    LNode *p, *q;
    p = L;
    L = nullptr;
    while (p) {
        q = p;
        p = p->next;
        q->next = L;
        L = q;
    }
}
```

## 3 双向链表

### 3.1 结点

![img](数据结构.assets/v2-afd5989520263063e49eae8b76328061_720w.png)

```C++
typedef struct DNode {
    ElemType data;
    struct DNode *prior;//前指针
    struct DNode *next;//后指针
} DNode, *DLinkList;
```

### 3.2 初始化

```C++
bool initList(DLinkList &L) {
    L = new DNode;//头结点
    if (!L)
        return false;
    L->prior = nullptr;//头结点prior指向空
    L->next = nullptr;
    return true;
}
```

### 3.3 判空

```C++
bool empty(DLinkList L) {
    if (!L->next)
        return false;
    else
        return true;
}
```

### 3.4 插入结点

```C++
//在p结点后插入s结点
bool insert_next_node(DNode *p, DNode *s) {
    if (!p || !s)
        return false;
    s->next = p->next;
    if (p->next)//如果p结点有后继节点
        p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
```

### 3.5 删除结点

```C++
//删除结点p的后继节点
bool delete_next_node(DNode *p) {
    if (!p || !p->next)
        return false;
    DNode *q = p->next;
    p->next = q->next;
    if (q->next)
        q->next->prior = p;
    delete q;
    return true;
}
```

### 3.6 按位查找

```C++
//按位查找，返回第i个结点
DNode *get_elem(DLinkList &L, int i) {
    if (!L)
        return nullptr;
    int j = 1;
    DNode *p = L->next;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}
```

### 3.7 后插法

```C++
bool insert_tail_list(DLinkList &L) {
    if (!L)
        return false;
    L = new  DNode;
    L->prior= nullptr;
    ElemType x;
    DNode *p, *s;
    p = L;
    if (!p)
        return false;
    cin >> x;
    while (x != 9999) {
        s = new DNode;
        s->data = x;
        s->prior = p;
        p->next = s;
        p = s;
        cin >> x;
    }
    p->next = nullptr;
    return true;
}
```

### 3.8 遍历

#### 1） 后向遍历

```C++
//后向遍历打印双链表
void next_to_string(DLinkList L) {
    if (!L)
        exit(-1);
    cout << "打印双链表：";
    DNode *p = L->next;//首元结点
    while (p) {
        cout << p->data << " ";
        p = p->next;
    }
    cout << endl;
}
```

#### 2） 前向遍历

```C++
//前向遍历打印链表
void prior_to_string(DNode *p){//p为表中最后一个结点
    cout << "前项遍历链表：";
    while(p->prior){//p->prior为空表示当前p已经指向头指针
        cout << p->data << " ";
        p=p->prior;
    }
    cout << endl;
}
```

时间复杂度=O(n)

## 4  循环链表

### 4.1 循环单链表

**特点：**

1.  表尾指针的next指向头结点
2.  从一个节点出发，可以找到其他任何一个结点。

#### 1）初始化

```
bool init_list(LinkList &L) {
    L = new LNode;
    if (!L)
        return false;
    L->next = L;
    return true;
}
```

#### 2）判空

```C++
bool empty(LinkList L) {
    if (L->next == L)
        return true;
    else
        return false;
}
```

#### 3）判断结点是否是表尾结点

```C++
bool is_tail(LinkList L, LNode *p) {
    if (p->next == L)
        return true;
    else
        return false;
}
```

### 4.2 循环双链表

**特点：**

1.  表头指针prior指向表尾结点
2.  表尾指针的next指向头结点

#### 1）初始化

```C++
bool init_list(DLinkList &L) {
    L = new DNode;
    if (!L)
        return false;
    L->prior = L;
    L->next = L;
    return true;
}
```

#### 2）判空

```C+=
bool empty(DLinkList L) {
    if (L->next == L)
        return true;
    else
        return false;
}
```

#### 3）判断结点是否为表尾结点

```C++
bool is_tail(DLinkList L, DNode *p) {
    if (p->next == L)
        return true;
    else
        return false;
}
```

#### 4）插入

```C++
//结点p后插入元素值为e的结点
bool insert_next_node(DNode *p, ElemType e) {
    if (!p)
        return false;
    DNode *s = new DNode;
    s->data = e;
    s->next = p->next;
    if (p->next)
        p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
```

#### 5）删除

```C++
//删除结点p后的结点
bool delete_next_node(DNode *p) {
    if (!p || !p->next)
        return false;
    DNode *q = p->next;
    p->next = q->next;
    if (q->next)
        q->next->prior = p;
    delete q;
    return true;
}
```

#### 6）获取结点

```C++
//获取第i个结点
DNode *get_elem(DLinkList L, int i) {
    if (i < 1 || !L)
        return nullptr;
    DNode *p = L->next;
    int j = 1;
    while (p != L && j < i) {
        p = p->next;
        j++;
    }
    if (p == L)
        return nullptr;
    return p;
}
```

## 5 静态链表（不一定考）

**特点：**分配一整片连续的内存空间，各个结点集中安置

**优点：**增删操作不需要大量移动元素

**缺点：**不能随机存取，只能从头结点开始依次往后查找；==容量固定不可变==

**使用场景：**1）不支持指针的低级语言；2）数据元素数量固定不变的场景(如操作系统的文件分配表FAT)

<img src="数据结构.assets/image-20220817153449287.png" alt="image-20220817153449287" style="zoom:50%;" />  

**结点：**

```C++
struct Node{
    ElemType data;
    int next;//游标，充当指针，指向下一个元素的数组下标
};
struct Node node[MAX_SIZE];//初始化
//或者
typedef struct{
    ElemType data;
    int next;
}SLinkList[MAX_SIZE];
SLinkList sLinkList;//初始化
```



### 1）查找

从头结点出发挨个往后遍历

时间复杂度=O(n)

### 2）插入位序为i的结点

1.  找到一个空的结点，存入数据
2.  从头结点出发找到位序为i-1的结点
3.  修改新结点的next
4.  修改i-1号结点的next

### 3）删除某个结点

1.  从头结点出发找到前驱结点
2.  修改前驱节点的游标
3.  被删除结点next设置为-2(设置为-2只是为了表示next为空)

## 6 顺序表和链表的对比

### 1）逻辑结构

都属于线性表，都是线性结构

### 2）存储结构

**顺序表：**采用==顺序存储==，逻辑上相邻的元素，对应的物理存储位置也相邻

1.  优点：支持随机存取，存储密度高
2.  缺点：大片连续空间分配不方便，改变容量不方便，会出现空间闲置或溢出的现象

**链表：**采用==链式存储==，逻辑上相邻的元素，物理存储位置不一定相邻

1.  优点：理想的小空间分配方便，改变容量方便，不会出现空间闲置或溢出现象
2.  缺点：不可随机存取，存储密度低

### 3）基本操作

**创建操作：**

-   顺序表
    -   静态分配，需要与分配一大块连续的内存空间，会造成浪费或溢出，容量不可改变。
    -   也可采用动态分配，容量可以改变，但是需要移动大量的元素，时间代价高
-   链表：动态分配，只需要先申请一个头结点，容量可改变

**销毁操作：**

-   顺序表：系统自动回收内存空间
-   链表：需要手动申请和释放内存

**插入、删除操作：**

-   顺序表：
    -   插入/删除元素需要将后续元素都后移/前移
    -   时间复杂度O(n)，时间开销主要来自移动元素
-   链表：
    -   插入/删除元素只需要修改指针即可
    -   时间复杂度O(n)，时间开销主要来自查找目标元素

**查找操作：**

-   顺序表：
    -   按位查找：O(1)
    -   按值查找：O(n)，若表内有序可采用折半查找，时间复杂度O(log~2~n)
-   链表：
    -   按位查找：O(n)
    -   按值查找：O(n)

### 4）顺序表和链表的选择

|                | 顺序表 | 链表 |
| :------------: | :----: | :--: |
| 弹性（可扩容） |   ×    |  √   |
|     增、删     |   ×    |  √   |
|       查       |   √    |  ×   |

## 7 线性表的应用

### 7.1 线性表的合并

**步骤：**

1.  分别获取LA表长m、LB表长n
2.  遍历LB表，如果表中元素不在A中，插入到LA表后

```C++
//顺序表为例
void merge_list(SeqList &s1,SeqList &s2){
    int m=Length(s1);
    int n=Length(s2);
    for (int i = 0; i < n; i++) {
        ElemType x = s2.GetElem(s2,i+1);
        if(!LocateElem(s1,x))
            ListInsert(s1,++m,x);
    }
}
```

**时间复杂度=O(m*n)**，顺序表和链表都是。

### 7.2 有序表的合并

#### 1）有序顺序表的合并

```C++
void merge_list_seq(SeqList LA, SeqList LB, SeqList &LC) {
    if ((LA.length + LB.length) > LC.MaxSize)
        LC.IncreaseList(LA.length + LB.length - LC.length);//扩展LC的容量
    int a = 0, b = 0, c = 0;
    while (a < LA.length && b < LB.length) {//遍历LA和LB
        if (LA.data[a] <= LB.data[b])//两两相比，把小的那个元素插入到LC表
            LC.data[c++] = LA.data[a++];
        else
            LC.data[c++] = LB.data[b++];
    }
    while (a < LA.length)//如果LA表还有剩余元素，插入到LC表中
        LC.data[c++] = LA.data[a++];
    while (b < LB.length)//如果LB表还有剩余元素，插入到LC表中
        LC.data[c++] = LB.data[b++];
    LC.length = c;
}
```

# 三、栈、队列、数组

## 1 栈

### 1.1 栈的定义和特点

#### 1.1 .1栈的基本概念

**定义：**栈是==只允许在一端进行插入或删除操作==的线性表

**术语：**

1.  栈顶：表尾，允许插入和删除的一端
2.  栈底：表头，不允许插入和删除的一端
3.  空栈：不含元素的空表。

**特点：**后进先出（Last In First Out，LIFO）

#### 1.1.2 栈的抽象数据类型定义

```C++
ADT Stack {
    数据对象：D = {ai|ai∈ElemSet，i=1,2,3,...,n,n≥0}// ElemSet 表示元素的集合
    数据关系：R1={<ai-1,ai>|ai-1,ai∈D，i=2,...,n}// ai-1为前驱，ai为后继
            约定 an 端为栈顶，a1 端为栈底
	基本操作：
        InitStack（&S）初始化操作
            操作结果：构造一个空栈 S
        DestroyStack（&S）销毁栈操作
            初始条件：栈S已存在
            操作结果：栈S被销毁
        ClearStack（&S）栈指控操作
            初始条件：栈S已存在
            操作结果：将S清为空栈
        StackEmpty（S）判定栈是否为空栈
            初始条件：栈S已存在
            操作结果：若栈S为空栈，则返回true,若栈S为非空，则返回false
        StackLength（S）求栈的长度
            初始条件：栈S已存在
            操作结果：返回栈S的元素个数，即栈的长度
        GetTop（S）取栈顶元素
            初始条件：栈S已存在且非空
            操作结果：返回S的栈顶元素，不修改栈顶指针
        Push（&S，e）入栈操作
            初始条件：栈S已存在
            操作结果：插入元素e为新的栈顶元素
        Pop（&S，&e）出栈操作
            初始条件：栈S存在且非空
            操作结果：删除栈S的栈顶元素，并用e返回其值
        StackTraverse(S)
            初始条件：栈S已存在且非空
            操作结果：从栈底到栈顶依次对S的每个数据元素进行访问
}ADT Stack

```

#### 1.1.3 基本操作

```C++
InitStack(&S)：初始化栈。构造一个空栈S，分配内存空间。
DestroyStack(&L)：销毁栈。销毁并释放栈S所占用的内存空间。
Push(&S,x)：进栈。若栈S未满，则将x加入使之成为新的栈顶。
Pop(&S,&x)：出栈。若栈S非空，则弹出栈顶元素，并用x返回。
GetTop(S,&x)：读栈顶元素。若栈S非空，则用x返回栈顶元素。
StackEmpty(S)：判空操作。若S为空栈，则返回true，否则返回false。
```

#### 1.1.4  卡特兰数

n个不同元素进栈，出栈元素不同排列的个数$\frac{1}{n+1}\C_{2n}^{n}$

### 1.2  栈的顺序存储的实现

#### 1.2.1 顺序栈的定义

顺序栈：利用顺序存储结构实现的栈，用静态数组实现，需要记录栈顶指针

```C++
#define MAX_SIZE 10
typedef int ElemType;
typedef struct{
    ElemType data[MAX_SIZE];
    int top;
}SqStack;
```

#### 1.2.2 顺序栈的基本操作的实现

```C++
#define MAX_SIZE 10
typedef int ElemType;
typedef struct {
    ElemType data[MAX_SIZE];
    int top;
} SqStack;
//初始化栈
void InitStack(SqStack &S) {
    S.top = 0;
}
//判空
bool Empty(SqStack S) {
    if (S.top == 0)
        return true;
    else
        return false;
}
//入栈
bool Push(SqStack &S, ElemType x) {
    if (S.top == MAX_SIZE)//栈满
        return false;
    S.data[S.top++] = x;//新元素入栈
    return true;
}
//出栈
bool Pop(SqStack &S, ElemType &x) {
    if (S.top == 0)//栈空
        return false;
    x = S.data[--S.top];
    return true;
}
//读栈顶
bool GetTop(SqStack S, ElemType &x) {
    if (S.top == 0)
        return false;
    x = S.data[S.top-1];
    return true;
}
```

创、增、删、查 时间复杂度为O(1)

### 1.3 共享栈

#### 1.3.1 共享栈的定义

共享栈：两个栈共享一片内存空间

<img src="数据结构.assets/Snipaste_2022-08-19_22-08-32.png" alt="Snipaste_2022-08-19_22-08-32" style="zoom: 50%;" />

#### 1.3.2 共享栈的实现

```C++
#define MAX_SIZE 10
typedef int ElemType;
typedef struct {
    ElemType data[MAX_SIZE];
    int top0;
    int top1;
} ShareStack;
//初始化
void InitStacki(ShareStack &S) {
    S.top0 == -1;
    S.top1 == MAX_SIZE;
}
//判空
bool Empty(ShareStack S) {
    if (S.top0 == -1 && S.top1 == MAX_SIZE)
        return true;
    else
        return false;
}
//判断栈满
S.top0+1==S.top1;
```

### 1.3 栈的链式存储的实现

#### 1.3.1 链式栈的实现

```C++
typedef int ElemType;
typedef struct StackNode {
    ElemType data;
    struct StackNode *next;
} StackNode, *LinkStack;
//初始化
void InitStack(LinkStack &S) {
    S = nullptr;
}
//入栈
bool Push(LinkStack &S, ElemType x) {
    StackNode *s = new StackNode;
    s->data = x;
    s->next = S;
    S = s;
}
//出栈
bool Pop(LinkStack &S, ElemType &e) {
    if (!S)
        return false;
    e = S->data;
    StackNode *p = S;
    S = S->next;
    delete p;
    return true;
}
//取栈顶元素
bool GetTop(LinkStack S, ElemType &e) {
    if (!S)
        return false;
    e = S->data;
    return true;
}
```

#### 1.3.2 汉诺塔问题的递归算法

**算法步骤：**

1.  如果n=1，则直接将编号为1的圆盘从A移到C，递归结束
2.  否则：
    -   递归，将A上编号为1至n-1的圆盘移动到B，C做辅助塔
    -   直接将编号为n的圆盘从A移到C
    -   递归，将B上编号为1至n-1的圆盘移动到C，A做辅助塔

```C++
void move(LinkStack &from, LinkStack &to) {
    ElemType data;
    Pop(from, data);
    Push(to, data);
}
void hanoi(int n, LinkStack &A, LinkStack &B, LinkStack &C) {
    if (n == 1)
        move(A, C);
    else {
        hanoi(n - 1, A, C, B);
        move(A, C);
        hanoi(n - 1, B, A, C);
    }
}
```

**时间复杂度=O(2^n^)**

**空间复杂度=O(n)**

## 2 队列

### 2.1 队列的定义和特点

#### 2.1.1 队列的概念

**定义：**队列是只允许在一端进行插入，在另一端进行删除的线性表。

**特点：**先进先出 (First In First Out，FIFO)

**术语：**

-   队头：允许删除的一端，又称队首。
-   队尾：允许插入的一端。
-   空队列：不含任何元素的空表。

#### 2.1.2 队列的抽象数据类型定义

```C++
ADT Queue{
	数据对象：D = {ai|ai∈ElemSet，i=1,2,3,...,n,n≥0}
    数据关系：R1={<ai-1,ai>|ai-1,ai∈D，i=2,...,n}
    		约定 a1 端为队列头，an端为队列尾
	基本操作：
		InitQueue(&Q)
			操作结果：构造一个空队列Q
		DestroyQueue(&Q)
			初始条件：队列Q已存在
			操作结果：队列Q被销毁，不再存在
		ClearQueue(&Q)
			初始条件：队列Q已存在
			操作结果：将Q清为空队列
		QueueEmpty(Q)
			初始条件：队列Q已存在
			操作结果：若Q为空队列，则返回true，否则返回false
		GetHead(Q)
			初始条件：Q为非空队列
			操作结果：返回Q的队头元素
		EnQueue(&Q,e)
			初始条件：队列Q已存在
			操作结果：插入元素e为Q的新的队尾元素
		DeQueue(&Q,&e)
			初始条件：Q为非空队列
			操作结果：删除Q的队头元素，并用e返回其值
		QueueTraverse(&Q)
			初始条件：Q已存在且非空
			操作结果：从队头到队尾，依次对Q的每个数据元素访问
}ADT Queue
```

#### 2.1.3 基本操作

```C++
InitQueue(&Q)：初始化队列，构造一个空队列Q。
DestroyQueue(&Q)：销毁队列。销毁并释放队列Q所占用的内存空间。
EnQueue(&Q,x)：入队，若Q未满，将x加入，使之成为新的队尾。
DeQueue(&Q,&x)：出队，若Q非空，删除队头元素，并用x返回。
GetHead(Q,&x)：度队头元素，若队列Q非空，则将队头元素赋值给x。
QueueEmpty(Q)：判断队空，若队列Q为空返回true，否则返回false。
```

### 2.2 队列的顺序实现

#### 2.2.1 循环队列

```C++
#define MAX_SIZE 10//队列初始容量
typedef int ElemType;
//队列的顺序存储结构
typedef struct {
    ElemType *data;
    int front;//队头指针
    int rear;//队尾指针
} SqQueue;
//初始化
bool InitQueue(SqQueue &Q) {
    Q.data = new ElemType[MAX_SIZE];
    if (!Q.data)
        return false;
    Q.front = Q.rear = 0;
    return true;
}
//判空
bool QueueEmpty(SqQueue Q) {
    if (Q.front == Q.rear)//队空条件
        return true;
    else
        return false;
}
//入队
bool EnQueue(SqQueue &Q, ElemType e) {
    if ((Q.rear + 1) % MAX_SIZE == Q.front)//队满
        return false;
    Q.data[Q.rear] = e;//添加数据
    Q.rear = (Q.rear + 1) % MAX_SIZE;//循环队列，队尾指针+1
    return true;
}
//出队
bool DeQueue(SqQueue &Q, ElemType &e) {
    if (Q.front == Q.rear)//队空
        return false;
    e = Q.data[Q.front];//保存队头元素
    Q.front = (Q.front + 1) % MAX_SIZE;//队头指针加1
    return true;
}
//取队头元素
bool GetHead(SqQueue Q, ElemType &e) {
    if (Q.front == Q.rear)
        return false;
    e = Q.data[Q.front];
    return true;
}
//求循环队列长度
int Length(SqQueue Q) {
    return (Q.rear - Q.front + MAX_SIZE) % MAX_SIZE;
}
```

#### 2.2.2 判断队满\队空的三种方式

**第一种方式：**上述循环队列操作中的方式

-   队满：(Q.rear + 1) % MAX_SIZE == Q.front
-   队空：Q.front == Q.rear

<img src="数据结构.assets/image-20220821231557652.png" alt="image-20220821231557652" style="zoom:50%;" />

**注意：**这种方式下，数组空间中会有一个位置的浪费。

**第二种方式：**

如果想要不浪费这一个空间，需要在结构体中添加一个size属性，用来记录队列的长度，在进行入队出队操作的时候size++或者size--，判断队满size==MAXSIZE

```C++
//队列的顺序存储结构
typedef struct {
    ElemType *data;
    int front;//队头指针
    int rear;//队尾指针
    int size;
} SqQueue;
//初始化
bool InitQueue(SqQueue &Q) {
    Q.data = new ElemType[MAX_SIZE];
    if (!Q.data)
        return false;
    Q.front = Q.rear = 0;
    Q.size = 0;
    return true;
}
```

-   队满：Q.size == MAX_SIZE
-   队空：Q.size == 0

**第三种方式：**

​		结构体中添加一个tag属性，用来记录最近一次的插入或者删除操作。删除操作完成时设置tag\=0，插入操作完成时设置tag\=1。只有删除操作，才可能导致队空；只有插入操作，才可能导致队满。

```C++
#define MAX_SIZE 10//队列初始容量
typedef int ElemType;
typedef struct {
    ElemType *data;
    int front;//队头指针
    int rear;//队尾指针
    int tag;//入队操作后设为1，出队操作后设为0
} SqQueue;

//初始化
bool InitQueue(SqQueue &Q) {
    Q.data = new ElemType[MAX_SIZE];
    if (!Q.data)
        return false;
    Q.front = Q.rear = 0;
    Q.tag = 0;
    return true;
}
```

-   队空：Q.rear == Q.front && Q.tag == 0
-   队满：Q.rear == Q.front && Q.tag == 1

### 2.3 队列的链式实现

#### 2.3.1 带头结点（方便操作）

```C++
typedef int ElemType;
typedef struct LinkNode {
    ElemType data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front;
    LinkNode *rear;
} LinkQueue;
//初始化
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = new LinkNode;//头结点
    Q.front->next = nullptr;//头结点的指针域置空
}
//判空
bool Empty(LinkQueue Q) {
    if (Q.front == Q.rear)
        return true;
    else
        return false;
}
//入队
bool EnQueue(LinkQueue &Q, ElemType e) {
    LinkNode *s = new LinkNode;
    s->data = e;
    s->next = nullptr;
    Q.rear->next = s;
    Q.rear = s;
    return true;
}
//出队
bool DeQueue(LinkQueue &Q, ElemType &e) {
    if (Q.rear == Q.front)
        return false;
    LinkNode *p = Q.front->next;
    e = p->data;
    Q.front->next = p->next;
    if (Q.rear == p)
        Q.rear = Q.front;
    delete p;
    return true;
}
//取队头元素
bool GetHead(LinkQueue Q, ElemType &e) {
    if (Q.rear == Q.front)
        return false;
    e = Q.front->next->data;
    return true;
}
//获取队列长度
int Length(LinkQueue Q) {
    if (Q.front == Q.rear)
        return 0;
    int len = 0;
    LinkNode *p = Q.front;
    while (p->next) {
        p = p->next;
        len++;
    }
    return len;
}
//遍历
bool traverse(LinkQueue Q) {
    if (Q.rear == Q.front)
        return false;
    std::cout << "打印链式队列：";
    LinkNode *p = Q.front->next;
    while (p) {
        std::cout << p->data << "\t";
        p = p->next;
    }
    std::cout << std::endl;
    return true;
}
```

#### 2.3.2 不带头结点

```C++
typedef int ElemType;
typedef struct LinkNode {
    ElemType data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front;
    LinkNode *rear;
} LinkQueue;
//初始化
void InitQueue(LinkQueue &Q) {
    Q.front = nullptr;
    Q.rear = nullptr;
}
//判空
bool Empty(LinkQueue &Q) {
    if (Q.front == nullptr)
        return true;
    else
        return false;
}
//入队
bool EnQueue(LinkQueue &Q, ElemType e) {
    LinkNode *s = new LinkNode;
    s->data = e;
    s->next = nullptr;
    if (Q.front == nullptr) {//在队列中插入第一个结点
        Q.front = s;
        Q.rear = s;
    } else {
        Q.rear->next = s;//新结点插入到Q.rear之后
        Q.rear = s;//修改Q.rear
    }
    return true;
}
//出队
bool DeQueue(LinkQueue &Q, ElemType &e) {
    if (Q.front == nullptr)
        return false;
    LinkNode *p = Q.front;
    e = p->data;
    Q.front = p->next;
    if (p == Q.rear) {//如果删除的p是最后一个结点
        Q.rear = nullptr;
        Q.front = nullptr;
    }
    delete p;
    return true;
}
//获取队列长度
int Length(LinkQueue Q) {
    if (Q.front == nullptr)
        return 0;
    int len = 0;
    LinkNode *p = Q.front;
    while (p) {
        p = p->next;
        len++;
    }
    return len;
}
//遍历
bool traverse(LinkQueue Q) {
    if (Q.front == nullptr)
        return false;
    LinkNode *p = Q.front;
    while (p) {
        std::cout << p->data << "\t";
        p = p->next;
    }
    std::cout << std::endl;
    return true;
}
```

### 2.4 双端队列

**分类：**

-   双端队列：只允许从==两端插入==、==两端删除==的线性表。
-   输入受限的双端队列：只允许从==一端输入==，==两端删除==的线性表
-   输出受限的双端队列：只允许从==两端插入==，==一端删除==的线性表

**考点：**判断输出序列合法性

**PS：**在栈中合法的输出序列，在双端队列中必定合法

## 3 栈的应用

### 3.1 括号匹配

**实现思路：**依次扫描所有字符，遇到左括号入栈，遇到有括号则弹出栈顶元素检查是否匹配

**匹配失败情况：**

1.  右括号和左括号不匹配
2.  右括号消耗完，左括号还有剩余（左括号单身）
3.  左括号消耗完，还有有括号（右括号单身）

<img src="数据结构.assets/image-20220823180221476.png" alt="image-20220823180221476" style="zoom: 80%;" />

**代码实现：**

```C++
bool bracket(char str[], int length) {
    LinkStack S;
    InitStack(S);
    for (int i = 0; i < length; i++) {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{') {
            Push(S, str[i]);//扫描到左括号，出栈
        } else {
            if (Empty(S))//匹配到右括号，且当前栈空
                return false;//匹配失败
            char topElem;
            Pop(S, topElem);//在栈顶元素出栈
            if (str[i] == ')' && topElem != '(')
                return false;
            if (str[i] == ']' && topElem != '[')
                return false;
            if (str[i] == '}' && topElem != '{')
                return false;
        }
    }
    return Empty(S);
}
```

### 3.2 表达式求值

**三种算术表达式：**

1.  中缀表达式：运算符在两个操作数中间，例：a+b-c*d
2.  后缀表达式（逆波兰表达式）：运算符在两个操作数后面，例：ab+cd*-
3.  前缀表达式（波兰表达式）：运算符在两个操作数前面，例：-+ad*cd

**表达式的三种成分：**操作数、运算符、界限符(括号)

#### 3.2.1 中缀表达式转后缀表达式

##### **1）手算方法：**

1.  确定中缀表达式中各个运算符的运算顺序
2.  选择下一个运算符，按照==\[左操作数 右操作数 运算符\]==的方式组合成一个新的操作数
3.  如果还有运算符没被处理，就继续步骤2

**注：**由于运算顺序不唯一，因此对应的后缀表达式也不唯一

**例：**A+B*(C-D)-E/F

转后缀表达式：ABCD-*+EF/-（计算机应该得到的结果）

​						   ABCD-*EF/-+

**注：**要保证==手算和机算结果相同（为了确保算法的”正确性“）==，应采用“左优先”原则

>   **==”左优先”原则：==**只要左边的运算符能先计算，就优先算左边的

**例：**A+B-C\*D/E+F ==> AB+CD\*F/-F+

##### 2）机算方法：

1.  初始化一个栈，用于保存暂时还不能确定运算顺序的运算符
2.  从左到右处理各个元素，直到末尾。可能遇到三种情况：
    1.  遇到==操作数==。直接加入后缀表达式。
    2.  遇到==界限符==。遇到'('直接入栈；遇到')'则依次弹出栈内运算符并加入后缀表达式，知道弹出'('为止。注意：'('不加入后缀表达式。
    3.  遇到==运算符==。依次弹出栈内==优先级==高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到'('或栈空则停止。之后再把当前运算符入栈。
3.  按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式

#### 3.2.2 后缀表达式的计算

**后缀表达式的手算方法：**

​	从左往右扫描，每遇到一个运算符，就让==运算符前面最近的两个操作数==执行对应运算，合为一个操作数

**用栈实现后缀表达式的计算：**

1.  ==从左到右==扫描下一个元素，直到处理完所有元素

2.  若扫描到操作数则压入栈，并返回步骤1；否则执行步骤3

3.  若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压入栈顶，回到步骤1

    >   注意：先出栈的是右操作数

#### 3.2.3 中缀表达式转前缀表达式

**手算方法：**

1.  确定中缀表达式中各个运算符的运算顺序
2.  选择下一个运算符，按照==\[运算符 左操作数 右操作数\]==的方式组合成一个新的操作数
3.  如果还有运算符没被处理，就继续步骤2

**”右优先“原则：**只要右边的运算符能先计算，就优先算右边的

**注：**一个中缀表达式可以对应多个后缀、前缀表达式

#### 3.2.4 前缀表达式的计算

**用栈实现前缀表达式的计算：**

1.  ==从右往左==扫描下一个元素，知道处理完所有元素
2.  若扫描到操作数则压入栈，并回到步骤1；否则执行步骤3
3.  若扫描到运算符，则弹出两个栈顶元素， 执行相应运算，运算结果压入栈顶，回到步骤1

>   注意：先出栈的是左操作数

#### 3.2.5 中缀表达式的计算

**用栈实现中缀表达式的计算：**

1.  初始化两个栈，==操作数栈==和==运算符栈==
2.  若扫描到操作数，压入操作数栈
3.  若扫描到运算符或界限符，则按照“中缀转后缀”相同逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应的运算，运算结果在压回操作数栈）



### 3.3 递归中的应用

#### 3.2.1 递归

**递归调用**其实就是**特殊的函数调用**，只不过它**调用的函数是其本身**而已。

**函数调用的特点：**最后被调用的函数最先执行结束（LIFO）

函数调用时需要用一个栈存储：

1.  调用返回地址
2.  实参
3.  局部变量

**递归算法的两部分：**

1.  递归表达式（递归体）
2.  边界条件（递归出口）

>   **缺点：**递归层数太多会导致栈溢出。
>
>   **缺点：**可能包含很多重复计算。

#### 3.3.2 阶乘

```C++
int factorial(int n) {
    if (n == 0 || n == 1)
        return 1;
    else
        return n * factorial(n - 1);
}
```

#### 3.3.3 斐波那契数列

```C++
int fib(int n) {
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;
    else
        return fib(n - 1) + fib(n - 2);
}
```

#### 3.3.4 利用栈将递归转换为非递归的方法

**利用栈消除递归的步骤：**

1.  设置一个工作栈存放递归工作记录（包括实参、返回地址、及局部变量等）
2.  进入非递归调用入口（即被调用程序开始处）将调用程序传来的实在参数和返回地址入栈（递归程序不可以作为主程序，因而可认为初始是被某个调用程序调用）。
3.  进入递归调用入口：当不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈，这一过程可用循环语句来实现——模拟递归分解的过程。
4.  递归结束条件满足，将到达递归出口的给定常数作为当前的函数值。
5.  返回处理：在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作，即逐层计算当前函数值，直至占空为止——模拟递归求值过程。

#### 3.3.5 用栈实现的非递归阶乘

```C++
int non_recursion_factorial_1(int n) {
    stack<int> stack;//新建一个栈，存储每层递归的计算结果
    int result = 1;
    if (n == 0 || n == 1)//边界条件
        return 1;
    while (n != 1 && n != 0)//while循环，将每层的计算结果入栈
        stack.push(n--);
    while (!stack.empty()) {//栈非空，逐层计算函数值，依次退栈，直到栈空
        result = result * stack.top();
        stack.pop();
    }
    return result;
}
```

## 4 队列的应用

树的遍历、图的广度优先遍历

## 5 特殊矩阵的压缩存储

### 5.1 数组的存储结构

1.  一维数组

    ```C++
    ElemType arr[10];
    ```

    内存：各数组元素大小相同，且物理上连续存放。已知起始地址，数组各元素的物理位置可以直接计算出来。

    | arr[0] | arr[1] | arr[2] | arr[3] | arr[4] | arr[5] | arr[6] | arr[7] | arr[8] | arr[9] |
    | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |

    起始地址LOC=arr[0]地址，则a[i]存放地址=LOC+i*sizeof(ElemType);

    注：除非特别说明，下表默认从0开始。

    ```
    例： int arr[10]={0,1,2,3,4,5,6,7,8,9};
    	int *p = arr;// *p = 0;
    	int *q=arr+3;// *q = 4;
    ```

2.  二维数组

    ```C++
    ElemType arr[2][3]={0,1,2,3,4,5};//两行三列的二维数组
    ```

    逻辑视角：

    | arr\[0\]\[0]      | arr\[0\]\[1\]     | arr\[0\]\[2\]     |
    | ----------------- | ----------------- | ----------------- |
    | **arr\[1\]\[0\]** | **arr\[1\]\[1\]** | **arr\[1\]\[2\]** |

    内存：（行优先存储）

    | arr\[0\]\[0] | arr\[0\]\[1\] | arr\[0\]\[2\] | arr\[1\]\[0\] | arr\[1\]\[1\] | arr\[1\]\[2\] |
    | ------------ | ------------- | ------------- | ------------- | ------------- | ------------- |

    M行N列二维数组arr\[M\]\[N\]

    arr[i\][j\]的存储地址=LOC+(i\*N+j)\*sizeof(ElemType);

    ```C++
    int arr[2][3]={0,1,2,3,4,5};
    int i=j=1;
    int *p=&arr[0][0]+i*N+j;// *p=4
    ```
    
    内存：（列优先存储）
    
    | arr\[0\]\[0] | arr\[1\]\[0\] | arr\[0\]\[1\] | arr\[1\]\[1\] | arr\[0\]\[2\] | arr\[1\]\[2\] |
    | ------------ | ------------- | ------------- | ------------- | ------------- | ------------- |
    
    M行N列二维数组arr\[M\]\[N\]
    
    arr[i\][j\]的存储地址=LOC+(j*M+i)\*sizeof(ElemType);
    
    ```C++
    int arr[2][3]={0,1,2,3,4,5};
    int i=j=1;
    int *p=&arr[0][0]+j*M+i;//*p=4
    ```

### 5.2 矩阵

**普通矩阵：**

可用二维数组存储。

>   **注：**矩阵的下表从1开始，数组的下标从0开始

**特殊矩阵：**

>   下列压缩策略中计算矩阵到数组的映射函数，可能需要用到等差数列的求和公式
>
>   $Sn=n*a1+\frac{n*(n-1)}{2}*d$ 或者 $Sn=\frac{n*(a1+an)}{2}$

1.  对称矩阵

    若n阶方阵中任意一个元素a~i,j~，都有a~i,j~=a~j,i~，责成该局真伪对称矩阵。

    普通存储：n*n二维数组。

    压缩存储策略：

    -   只存储主对角线+下三角区(i>j)

        -   按行优先原则将各元素存入一维数组中。

            | a~1,1~ | a~2,1~ | a~2,2~ | a~3,1~ | ······ | a~n,n-1~ | a~n,n~ |
            | ------ | ------ | ------ | ------ | ------ | -------- | ------ |

        -   **数组大小**为：1+2+3+······+n=$\frac{n*(n+1)}{2}$

        -   **使用方法：**构造一个映射函数，通过矩阵下标计算出数组下标。

            a~i,j~ --->  arr[k]

            按照行优先原则，a~i,j~是第1+2+3+···+(i-1)+j = $\frac{i*(i-1)}{2}+j$ 个元素

            $k=\frac{i*(i-1)}{2}+j-1$ 

    -   主对角线+上三角区(i<j)

        方法和上面类似。

2.  三角矩阵

    -   下三角矩阵：除了主对角线和下三角区，其余元素均为常量c。

        -   压缩存储策略：按行优先原则将下三角矩阵存入一维数组，并在最后一个位置存储常量c。

        -   | a~1,1~ | a~2,1~ | a~2,2~ | a~3,1~ | ······ | a~n,n-1~ | a~n,n~ | c    |
            | ------ | ------ | ------ | ------ | ------ | -------- | ------ | ---- |

        -   **数组大小：**$1+2+3+···+n+1=\frac{n*(n+1)}{2}+1$

        -   **使用方法：**构造映射函数

    -   上三角矩阵：与上面类似

3.  三对角矩阵：又称为带状矩阵，当$|i-j|>1$时，有a~i,j~=0($1≤i,j<n$)

    -   **压缩策略：**按行优先原则（或列优先原则），只存储带状部分

    -   **数组大小：**$2+3*(n-2)+2=3*n-2$

    -   已知矩阵元素下标，计算a~i,j~在数组中的位置，数组下标从0开始

        前$i-1$行共有$3*(i-1)-1$个元素

        a~i,j~是第i行第$j-i+2$个元素

        a~i,j~是第$2*i+j-2$个元素

        $k=2*i+j-3$

    -   已知数组下标k，计算矩阵元素下标a~i,j~

        明显可知$3*(i-1)-1<k+1≤3*i-1$

        $i≥\frac{k+2}{3}$ 可以理解为“刚好”大于等于

        向上取整 $i=⌈\frac{k+2}{3}⌉$ ，$j=k-2*i+3$

4.  稀疏矩阵:非零元素个数远远小于矩阵元素的个数

    -   压缩策略：

        -   顺序存储——三元组<行，列，值>

            ```C++
            struct node{
            	int i;
                int j;
                int value;
            };
            struct node arr[n];
            ```

            -   这种方式是访问稀疏矩阵只能顺序存取，失去了随机存取的特性

        -   十字链表法——链式存储

            ```C++
            //结点
            typedef struct OLNode{
                int i,j;//行标和列标
                int data;//数据
                struct OLNode *right,*down;//右指针和下指针
            }OLNode,*OLink;
            //十字链表结构体
            typedef struct{
                LONode *rhead,*chead;//行和列链表头指针
                int m,n,count;//行数、列数、非零元素个数
            }
            ```

            <img src="数据结构.assets/image-20220828163352907.png" alt="image-20220828163352907" style="zoom:50%;" /><img src="数据结构.assets/image-20220828163518353.png" alt="image-20220828163518353" style="zoom:50%;" />


### 5.3 矩阵考点易错点

1.  矩阵的压缩存储需要的数组大小
2.  由矩阵元素的行标和列标<i,j>推导出对应的数组下标k（数列求和）
3.  由数组下标k，推导出<i,j>
    1.  如何处理不等式中的“刚好大于等于/小于等于”
    2.  向上取整/向下取整
4.  易错点：
    1.  存储上三角？下三角
    2.  行优先存储？列优先存储？
    3.  矩阵下标从0？1？开始
    4.  数组下标从0？1？开始

# 四、串

## 1 串的定义

### 1.1 串的定义

**定义：**串(string)是由0个或多个字符组成的有限序列。一般记为 $S='a1a2···an'(n≥0)$

​		其中S是串名，单引号中的内容是串的值；a~i~可以是字母、数字或其他字符；串中字符的数目n称为串的长度。n=0时的串称为空串（用 ∅ 表示）。

**子串：**串中任意个连续的字符组成的子序列。（任意的意思是可以为0）

**主串：**包含子串的串相应的称为主串。

**字符在主串中的位置：**字符在串中的序号。

**子串在主串中的位置：**子串的第一个字符在主串中的位置。

**两个串相等：**当且仅当两个串的值相等。

**空格串：**由一个或多个空格组成的串“    ”称为空格串。

>   注意：空格串不是空串。

### 1.2串的特点

​		字符串一般简称为串。串是一种特殊的线性表，数据元素之间呈线性关系，其特殊性体现在数据元素是一个字符，也就是说，串是一种==内容受限的线性表==。

### 1.3 串的抽象数据类型

```C++
ADT String{
    数据对象：D={ai|ai∈CharacterSet,i=1,2,···,n,n≥0}
    数据关系：R1={<ai-1,ai>|ai-1,ai∈D,i=1,2,···,n}
    基本操作：
        StrAssign(%T,chars)//赋值操作
        	初始条件：chars是字符串常量
        	操作结果：生成一个其值等于chars的串T
        StrCopy(&T,S)//复制
        	初始条件：串S存在
        	操作结果：有串S复制得串T
        StrEmpty(S)//判空
        	初始条件：串S存在
        	操作结果：若S为空串，则返回true，否则返回false
        StrCompare(S,T)//比较
        	初始条件：串S和T存在
        	操作结果：若S>T,则返回值>0;若S=T,则返回值=0,若S<T,则返回值<0
        StrLength(S)//求串长
        	初始条件：串S存在
        	操作结果：返回串的元素个数，称为串的长度
        ClearString(&S)//清空串
        	初始条件：串S存在
        	操作结果：将S清为空串
        Concat($T,S1,S2)//串联接
        	初始条件：串S1和串S2存在
        	操作结果：用T返回由S1和S2连接而成的新串
        SubString(&Sub,S,pos,len)//获取子串
        	初始条件：串S存在,1≤pos≤StrLength(S)且0≤len≤StrLength(S)-pos+1
        	操作结果：用Sub返回串S的第pos个字符起长度为len的子串
        Index(S,T,pos)//定位子串
        	初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)
        	操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中的第pos个字符之后第一次出现的位置;否则函数值为0
        Replace(&S,T,V)//替换子串
        	初始条件：串S,T,V存在,T是非空串
        	操作结果：用V替换主串S中出现的所有与T相等的不重叠的字串
        StrInsert(&S,pos,T)//插入子串
        	初始条件：串S和T存在，1≤pos≤StrLength(S)+1
        	操作结果：在串S的第pos个字符之前插入串T
        StrDelete(&S,pos,len)//删除子串
        	初始条件：串S存在，1≤pos≤StrLength(S)-len+1
        	操作结果：从串S中删除第pos个字符起长度为len的子串
        DestroyString(&S)//销毁串
        	初始条件：串S存在
        	操作结果：串S被销毁
}
```

**字符串比较：**

1.  两个串逐字符对比，先出现较大字符那个串就大
2.  长串的前缀与短串相同时，长的那个大

### 1.4 字符集

1.  ASCII字符集——英文字符——八个比特位表示
2.  UniCode字符集——中英文

基于相同的字符集可以有多个不同的编码方式，比如:UTF-8、UTF-16等。

采用不同的编码方式，每个字符所占的空间不同，考研默认每个字符1B即可。

## 2 串的实现

### 2.1 串的顺序存储

**串的定长顺序存储结构：**

```C++
#define MAXLEN 255//串的最大长度
typedef struct{
    char ch[MAXLEN];
    int length;
}SString;
```

**串的堆式顺序存储结构 ：**

```C++
typedef struct{
    char *ch;//动态数组（堆分配存储）
    int length;
}HString;
```

**不同的实现方式：（选择方法4）**

![image-20220828181100585](数据结构.assets/image-20220828181100585.png)

### 2.2 串的链式存储

**结构1：**

```C++
typedef struct StringNode{
	char ch;
    struct StringNode *next;
}StringNode,*String;
```

**缺点：**存储密度低，每个字符1B，每个指针4B

**结构2：（提高存储密度）**

```C++
#define CHUNKSIZE 80//由用户定义的块大小
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;
typedef struct{
    Chunk *head,*tail;//串的头、尾指针
    int length;//串的当前长度
}LString;
```

>   注：如果某个结点的数组存不满，可以用特殊字符填充。

### 2.3 基本操作的实现

#### 2.3.1 SubString(&Sub,S,pos,len)

```C++
//求子串
bool SubString(SString &Sub,SString S,int pos,int len){
    if((pos+len-1)>S.length)
        return false;
    for(int i=pos;i<pos+len;i++)
        Sub.ch[i-pos+1]=S.ch[i];
    SUb.length=len;
    return true;
}
```



## 3 串的模式匹配
